#!/usr/bin/env python3

from elftools.elf.elffile import ELFFile
from elftools.elf.relocation import RelocationSection
from elftools.elf.sections import SymbolTableSection
from collections import defaultdict


def symbol_info(elf):
   # Dictionary to hold symbol name -> (defined status, type)
    sym_info = {}
    for section in elf.iter_sections():
        if not isinstance(section, SymbolTableSection): # .symtab or .dynsym
            continue
        for symbol in section.iter_symbols():
            name = symbol.name
            if (not name) or (name in sym_info):
                continue  # Skip unnamed symbols and duplicates

            if symbol['st_info']['bind'] == 'STB_LOCAL':
                continue  # Skip local symbols

            defined = symbol['st_shndx'] != 'SHN_UNDEF'
            st_type = symbol['st_info']['type']

            sym_info[name] = {
                'defined': defined,
                'type': st_type
            }
    return sym_info


def relocation_counts(elf):
    # Dictionary to hold symbol name -> count of relocations referencing it
    reloc_count = defaultdict(int)
    for section in elf.iter_sections():
        if not isinstance(section, RelocationSection):
            continue
        symtab = elf.get_section(section['sh_link'])
        assert(isinstance(symtab, SymbolTableSection))
        for reloc in section.iter_relocations():
            sym_index = reloc.entry.r_info_sym
            symbol = symtab.get_symbol(sym_index)
            name = symbol.name
            if not name:
                continue  # Skip unnamed symbols
            reloc_count[name] += 1
    return reloc_count


from collections import namedtuple
ObjectSymbols = namedtuple('ObjectSymbols', ['locals', 'globals'])

def object_symbols(elf):
    # Step 1: Parse symbol tables to get symbol definitions
    sym_info = symbol_info(elf)

    # Step 2: Parse relocation tables to count symbol usage
    reloc_count = relocation_counts(elf)

    # Step 3: Separate into defined (locals) and undefined (globals) symbols
    locals  = []
    globals = []
    for name in sym_info:
        info = sym_info[name]
        if info['defined']:
            locals.append(name)
        else:
            count = reloc_count.get(name, 0)
            entry = {
                'name': name,
                # 'type': info['type'],
                'reloc_count': count,
                'obj': []
            }
            globals.append(entry)
    return ObjectSymbols(locals, globals)


def main():
    import argparse
    from pathlib import Path

    parser = argparse.ArgumentParser(
                    prog='crefcount',
                    description='ELF Symbol Cross-Reference Counter')
    group = parser.add_mutually_exclusive_group(required=False)
    group.add_argument('-d', '--depfile', type=Path, help='path to depfile from linkers --dependency-file option')
    group.add_argument('-f', '--file', type=Path, help='path to object file (ignores -o option)')
    parser.add_argument('-C','--directory', type=Path, default=Path('.'), help='relative file paths are considered relative to this directory')
    parser.add_argument('-o', '--out', type=Path, default=Path('objects.json'), help='path to output json file')
    args = parser.parse_args()

    if args.file:
        with open(args.directory / args.file, 'rb') as f:
            elf = ELFFile(f)
            symbols = object_symbols(elf)

        print(f"Known (Defined) Symbols ({len(symbols.locals)}):")
        for name in symbols.locals:
            print(f"  Name: {name}")

        print(f"\nUnknown (Undefined) Symbols ({len(symbols.globals)}):")
        for entry in symbols.globals:
            print(f"  Name: {entry['name']}, "
                  f"Used in Relocations: {entry['reloc_count']}")


    elif args.directory:
        import json
        from progressbar import FormatCustomText, Percentage,  Bar, Timer, SmoothingETA, ProgressBar

        # Get all .o files
        OBJECT_FILES = []
        if args.depfile:
            with open(args.depfile, 'r') as f:
                for rawline in f:
                    line = rawline.strip()
                    if line.endswith('.o:'):
                        OBJECT_FILES.append(line.rstrip(':'))
        else:
            OBJECT_FILES = [f.name for f in args.directory.iterdir() if f.name.endswith('.o')]

        # Map symbol name -> list[object files that define it]
        symbol_objects_map: dict[str, list[str]] = {}
        # Map object file -> tuple(local symbol names, global symbol entries)
        object_symbols_map: dict[str, ObjectSymbols] = {}

        file_status = FormatCustomText(
            f'%(filename)s [%(number)s of {len(OBJECT_FILES)}]',
            {'filename': 'Initializing...', 'number': 1}
        )
        widgets = [file_status, ' ', Percentage(), ' ', Bar(), ' ',  Timer(), ' | ', SmoothingETA()]
        pbar = ProgressBar(widgets=widgets, max_value=len(OBJECT_FILES), redirect_stdout=True).start()

        # First pass: collect symbol definitions
        for i, obj in enumerate(OBJECT_FILES):
            filepath = Path(obj)
            if filepath.is_absolute():
                filepath = filepath.resolve()
                obj = str(filepath)
            else:
                filepath = args.directory / obj
            file_status.update_mapping(filename=filepath, number=i+1)
            with open(filepath, 'rb') as f:
                elf = ELFFile(f)
                symbols = object_symbols(elf)
                object_symbols_map[obj] = symbols
                for sym in symbols.locals:
                    if sym not in symbol_objects_map:
                        symbol_objects_map[sym] = []
                    symbol_objects_map[sym].append(obj)
            pbar.update(i+1)
            print(obj)
        pbar.finish()

        # Second pass: collect object names where globals defined
        for obj, symbols in object_symbols_map.items():
            for sym in symbols.globals:
                if sym['name'] not in symbol_objects_map:
                    continue
                sym['obj'].extend(symbol_objects_map[sym['name']])

        with open(args.out, 'w') as json_file:
            json.dump(object_symbols_map, json_file, indent=2)

if __name__ == '__main__':
    main()
